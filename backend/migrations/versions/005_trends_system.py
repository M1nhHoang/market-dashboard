"""
005 - Trends System: Merge Themes + Signals into unified Trends

Revision ID: 005_trends_system
Revises: 004_insights_system
Create Date: 2026-02-23

## WHY THIS MIGRATION?
Previously, Themes and Signals were separate concepts:
- Themes: Narrative groupings of events (e.g., "Căng thẳng thanh khoản")
- Signals: Individual predictions with expiry dates

This created UX problems:
- Hard to track which signals belong to which story
- Duplicate information between themes and signals
- No clear urgency indication on themes

## WHAT THIS MIGRATION DOES:
Extends themes table to serve as "Trends" - a unified view combining:
- Theme narrative (story/context)
- Linked signals (predictions with expiry)
- Computed urgency based on earliest signal expiry
- Signal accuracy tracking for the trend

The approach is ADDITIVE - we add columns to themes rather than creating
a new table, preserving existing data and avoiding breaking changes.

## HOW IT'S USED:
- Frontend: New "Trends" tab replaces both "Themes" and "Signals" tabs
- API: /api/trends endpoint returns themes with computed signal data
- Sidebar: Shows urgent trends with countdown based on signal expiry

## FIELDS ADDED:
- narrative: AI-synthesized summary of all signals' reasoning
- urgency: Computed from earliest signal expiry (urgent/watching/low)
- earliest_signal_expires: Cached for sorting
- signals_count: Active signals count
- signals_accuracy: Accuracy rate for verified signals in this trend
"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '005_trends_system'
down_revision: Union[str, None] = '004_insights_system'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """
    Add trend-specific fields to themes table.
    
    These fields transform themes into full "Trends" that include:
    - Narrative synthesis from signals
    - Urgency computation
    - Signal statistics
    """
    
    # ==================================================
    # EXTEND THEMES TABLE WITH TREND FIELDS
    # ==================================================
    
    with op.batch_alter_table('themes') as batch_op:
        # AI-synthesized narrative combining all signals' reasoning
        # Used in: TrendCard component, TrendDetail view
        # Generated by: LLM when signals are added to theme
        batch_op.add_column(
            sa.Column('narrative', sa.Text, nullable=True, 
                     comment='AI-synthesized summary of trend and all signal reasoning')
        )
        
        # Urgency level: computed from earliest signal expiry
        # Used in: Trend sorting, Urgent section in UI, Sidebar badges
        # Computed by: API layer or background job
        # Values: 'urgent' (<7 days), 'watching' (7-14 days), 'low' (>14 days), None (no signals)
        batch_op.add_column(
            sa.Column('urgency', sa.String(20), nullable=True, 
                     comment='Computed urgency: urgent/watching/low based on signal expiry')
        )
        
        # Cached earliest signal expiry for efficient sorting
        # Used in: Sorting trends by urgency in API queries
        # Updated by: When signals are added/removed from theme
        batch_op.add_column(
            sa.Column('earliest_signal_expires', sa.DateTime, nullable=True,
                     comment='Cached earliest expires_at from linked signals')
        )
        
        # Count of active signals for this trend
        # Used in: Trend cards to show "3 signals" badge
        # Updated by: When signals are added/verified/expired
        batch_op.add_column(
            sa.Column('signals_count', sa.Integer, default=0, nullable=True,
                     comment='Count of active signals linked to this trend')
        )
        
        # Accuracy rate for verified signals in this trend
        # Used in: Trend cards to show "2/3 correct" badge
        # Updated by: When signals are verified
        batch_op.add_column(
            sa.Column('signals_accuracy', sa.Float, nullable=True,
                     comment='Accuracy rate (0-1) for verified signals in this trend')
        )
        
        # Count of verified signals (for accuracy calculation)
        batch_op.add_column(
            sa.Column('signals_verified_count', sa.Integer, default=0, nullable=True,
                     comment='Total verified signals (correct + wrong)')
        )
        
        # Count of correct signals
        batch_op.add_column(
            sa.Column('signals_correct_count', sa.Integer, default=0, nullable=True,
                     comment='Count of verified_correct signals')
        )
        
        # Add index for urgency sorting
        batch_op.create_index(
            'idx_themes_urgency_expires',
            ['urgency', 'earliest_signal_expires']
        )
    
    # ==================================================
    # ADD signal_type TO SIGNALS TABLE
    # ==================================================
    # Classifies signals for different UI treatment:
    # - quantitative: Has target_range (shows "9.12% → 9.5-10%")
    # - directional: Only direction, no target (shows "↑ UP")
    # - event: Predicts event occurrence (shows "Expected: ...")
    
    with op.batch_alter_table('signals') as batch_op:
        batch_op.add_column(
            sa.Column('signal_type', sa.String(20), default='directional', nullable=True,
                     comment='Type: quantitative/directional/event for UI display')
        )
    
    # ==================================================
    # UPDATE EXISTING DATA
    # ==================================================
    # Auto-classify existing signals based on their fields
    
    op.execute("""
        UPDATE signals 
        SET signal_type = CASE
            WHEN target_range_low IS NOT NULL OR target_range_high IS NOT NULL THEN 'quantitative'
            WHEN direction IS NOT NULL THEN 'directional'
            ELSE 'event'
        END
        WHERE signal_type IS NULL
    """)
    
    # Compute initial signals_count for existing themes
    op.execute("""
        UPDATE themes
        SET signals_count = (
            SELECT COUNT(*) FROM signals 
            WHERE signals.theme_id = themes.id AND signals.status = 'active'
        )
    """)
    
    # Compute earliest_signal_expires for existing themes
    op.execute("""
        UPDATE themes
        SET earliest_signal_expires = (
            SELECT MIN(expires_at) FROM signals 
            WHERE signals.theme_id = themes.id 
            AND signals.status = 'active'
            AND signals.expires_at IS NOT NULL
        )
    """)
    
    # Compute urgency based on earliest_signal_expires
    op.execute("""
        UPDATE themes
        SET urgency = CASE
            WHEN earliest_signal_expires IS NULL THEN NULL
            WHEN earliest_signal_expires <= datetime('now', '+7 days') THEN 'urgent'
            WHEN earliest_signal_expires <= datetime('now', '+14 days') THEN 'watching'
            ELSE 'low'
        END
    """)


def downgrade() -> None:
    """Remove trend-specific fields from themes."""
    
    with op.batch_alter_table('signals') as batch_op:
        batch_op.drop_column('signal_type')
    
    with op.batch_alter_table('themes') as batch_op:
        batch_op.drop_index('idx_themes_urgency_expires')
        batch_op.drop_column('signals_correct_count')
        batch_op.drop_column('signals_verified_count')
        batch_op.drop_column('signals_accuracy')
        batch_op.drop_column('signals_count')
        batch_op.drop_column('earliest_signal_expires')
        batch_op.drop_column('urgency')
        batch_op.drop_column('narrative')
